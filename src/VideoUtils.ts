import { StreamApiClient } from './ApiClient';
import { promptUser } from './Utils';
import { logger } from './Logger';
import { Video, StreamSession, VideoUrl } from './Types';

import { AxiosResponse } from 'axios';
import fs from 'fs';
import { parse as parseDuration, Duration } from 'iso8601-duration';
import path from 'path';
import sanitizeWindowsName from 'sanitize-filename';
import { extractStreamGuids } from './Utils';

export function publishedDateToString(date: string): string {
    const dateJs: Date = new Date(date);
    const day: string = dateJs.getDate().toString().padStart(2, '0');
    const month: string = (dateJs.getMonth() + 1).toString(10).padStart(2, '0');

    return `${dateJs.getFullYear()}-${month}-${day}`;
}

export function publishedTimeToString(seconds: number): string
export function publishedTimeToString(date: string): string
export function publishedTimeToString(date: string | number): string {
    let dateJs: Date;

    if (typeof (date) === 'number') {
        dateJs = new Date(0, 0, 0, 0, 0, date);
    }
    else {
        dateJs = new Date(date);
    }

    const hours: string = dateJs.getHours().toString();
    const minutes: string = dateJs.getMinutes().toString();
    const seconds: string = dateJs.getSeconds().toString();

    return `${hours}h ${minutes}m ${seconds}s`;
}


export function isoDurationToString(time: string): string {
    const duration: Duration = parseDuration(time);

    return `${duration.hours ?? '00'}.${duration.minutes ?? '00'}.${duration.seconds?.toFixed(0) ?? '00'}`;
}

// it's the number of seconds in the video
export function durationToTotalChunks(duration: string,): number {
    const durationObj: any = parseDuration(duration);
    const hrs: number = durationObj.hours ?? 0;
    const mins: number = durationObj.minutes ?? 0;
    const secs: number = Math.ceil(durationObj.seconds ?? 0);

    return (hrs * 60 * 60) + (mins * 60) + secs;
}


export async function getStreamInfo(videoUrls: Array<VideoUrl>, session: StreamSession, subtitles?: boolean): Promise<Array<Video>> {
    const metadata: Array<Video> = [];
    let title: string;
    let duration: string;
    let publishDate: string;
    let publishTime: string;
    let author: string;
    let authorEmail: string;
    let uniqueId: string;
    let totalChunks: number;
    let playbackUrl: string;
    let posterImageUrl: string;
    let captionsUrl: string | undefined;

    const apiClient: StreamApiClient = StreamApiClient.getInstance(session);


    // we place the guid in the url field
    const videoGUIDs = await extractStreamGuids(videoUrls, session);


    /* TODO: change this to a single guid at a time to ease our footprint on the
    MSS servers or we get throttled after 10 sequential reqs */
    for (const guid of videoGUIDs) {
        const response: AxiosResponse<any> | undefined =
            await apiClient.callApi('videos/' + guid.url + '?$expand=creator', 'get');

        title = sanitizeWindowsName(response?.data['name']);

        duration = isoDurationToString(response?.data.media['duration']);

        publishDate = publishedDateToString(response?.data['publishedDate']);

        publishTime = publishedTimeToString(response?.data['publishedDate']);

        author = response?.data['creator'].name;

        authorEmail = response?.data['creator'].mail;

        uniqueId = '#' + guid.url.split('-')[0];

        totalChunks = durationToTotalChunks(response?.data.media['duration']);

        playbackUrl = response?.data['playbackUrls']
            .filter((item: { [x: string]: string; }) =>
                item['mimeType'] == 'application/vnd.apple.mpegurl')
            .map((item: { [x: string]: string }) => {
                return item['playbackUrl'];
            })[0];

        posterImageUrl = response?.data['posterImage']['medium']['url'];

        if (subtitles) {
            const captions: AxiosResponse<any> | undefined = await apiClient.callApi(`videos/${guid.url}/texttracks`, 'get');

            if (!captions?.data.value.length) {
                captionsUrl = undefined;
            }
            else if (captions?.data.value.length === 1) {
                logger.info(`Found subtitles for ${title}. \n`);
                captionsUrl = captions?.data.value.pop().url;
            }
            else {
                const index: number = promptUser(captions.data.value.map((item: { language: string; autoGenerated: string; }) => {
                    return `[${item.language}] autogenerated: ${item.autoGenerated}`;
                }));
                captionsUrl = captions.data.value[index].url;
            }
        }

        metadata.push({
            guid: guid.url,
            title,
            duration,
            publishDate,
            publishTime,
            author,
            authorEmail,
            uniqueId,
            outPath: guid.outDir,
            totalChunks,    // Abstraction of FFmpeg timemark
            playbackUrl,
            posterImageUrl,
            captionsUrl
        });
    }

    return metadata;
}


export function createUniquePath(videos: Array<Video>, template: string, format: string, skip?: boolean): Array<Video>
export function createUniquePath(videos: Video, template: string, format: string, skip?: boolean): Video
export function createUniquePath(videos: Array<Video> | Video, template: string, format: string, skip?: boolean): Array<Video> | Video {
    let singleInput = false;

    if (!Array.isArray(videos)) {
        videos = [videos];
        singleInput = true;
    }

    videos.forEach((video: Video) => {
        let title: string = template;
        let finalTitle: string;
        const elementRegEx = RegExp(/{(.*?)}/g);
        let match = elementRegEx.exec(template);

        while (match) {
            const value = video[match[1] as keyof (Video)] as string;
            title = title.replace(match[0], value);
            match = elementRegEx.exec(template);
        }

        let i = 0;
        finalTitle = title;

        while (!skip && fs.existsSync(path.join(video.outPath, finalTitle + '.' + format))) {
            finalTitle = `${title}.${++i}`;
        }

        const finalFileName = `${finalTitle}.${format}`;
        const cleanFileName = sanitizeWindowsName(finalFileName, { replacement: '_' });
        if (finalFileName !== cleanFileName) {
            logger.warn(`Not a valid Windows file name: "${finalFileName}".\nReplacing invalid characters with underscores to preserve cross-platform consistency.`);
        }

        video.outPath = path.join(video.outPath, finalFileName);

    });

    if (singleInput) {
        return videos[0];
    }

    return videos;
}
